from pygrametl.declarativeetl.parsing import *
import os


class PygramGenerator:
    def __init__(self):
        self.dim_blocks = []
        self.fact_blocks = []
        self.header = (
            "# This file was generated by PygramETL-DeclarativeETL in conformity with a given specification.\n"
            "# Credit Simon Mathiasen 2023 (AAU)\n"
            "\n"
            "import psycopg2\n"
            "import pygrametl\n"
            "from pygrametl.datasources import SQLSource, CSVSource\n"
            "from pygrametl.tables import CachedDimension, FactTable")

    def __generate_dimension(self, dimension: ParsedDimension):
        attribute_str = ""
        attribute: ParsedAttribute
        for attribute in dimension.members:
            attribute_str += f"'{attribute.name}' "

        dim_block = PythonCodeBlock(f"{dimension.name}_dimension = CachedDimension(", [
            f"name='{dimension.name}',",
            f"key='{dimension.keys[0]}',",
            f"attributes=[{attribute_str.strip()}])"])

        # TODO: Consider returning instead
        self.dim_blocks.append(dim_block)

    def __generate_fact_table(self, fact_table: ParsedFactTable):
        keyref_string = ", ".join(fact_table.keys)
        measure_list = []
        for measure in fact_table.members:
            measure_list.append(f"'{measure.name}'")
        measure_names = ", ".join(measure_list)
        fact_block = PythonCodeBlock(f"{fact_table.name}_fact_table = FactTable(", [
            f"name='{fact_table.name}',",
            f"keyrefs=[{keyref_string}],",
            f"measures=[{measure_names}])"
        ])

        # TODO: Consider returning instead
        self.fact_blocks.append(fact_block)

    def __generate_group(self, group: ParsedGroup):
        for dim in group.dimensions:
            self.__generate_dimension(dim)

        for fact in group.fact_tables:
            self.__generate_fact_table(fact)

    def create_pygram_file(self, specification: IntermediateSpecification):
        for dim in specification.dimensions:
            self.__generate_dimension(dim)
        for fact_table in specification.fact_tables:
            self.__generate_fact_table(fact_table)
        if specification.parsed_groups:
            for group in specification.parsed_groups:
                self.__generate_group(group)

        # TODO: Change for better output dir
        working_dir = os.getcwd()
        file = open(working_dir + "/Pygram-generated-setup.py", 'w')
        file.write(self.header + "\n\n")
        for block in self.dim_blocks:
            file.write(str(block))
            file.write("\n\n")
        for block in self.fact_blocks:
            file.write(str(block) + "\n\n")
        file.close()


class PythonCodeBlock:
    def __init__(self, head, block):
        self.head = head
        self.block = block

    def __str__(self, indent=""):
        result = indent + self.head + "\n"
        indent += "    "
        for block in self.block:
            if isinstance(block, PythonCodeBlock):
                result += block.__str__(indent)
            else:
                result += indent + block + "\n"
        return result
